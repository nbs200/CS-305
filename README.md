# CS-305-Projects

Artemis Financial was a mid-sized investment and financial planning firm aiming to modernize its client services. They wanted to streamline their operations by developing a secure, user-friendly web platform that could handle client onboarding, account management, and personalized financial planning tools.
The key issue they faced was an outdated system that made it difficult to scale services or ensure data security—especially with growing regulatory demands and a tech-savvy client base. They needed a solution that not only automated workflows but also protected sensitive data with strong encryption and secure authentication mechanisms.

When addressing Artemis Financial’s software security vulnerabilities, I began with a comprehensive audit using tools like OWASP Dependency-Check and manual code reviews to identify outdated libraries, insecure configurations, and weak authentication controls. Each vulnerability was clearly documented, highlighting its risk level, affected components, and actionable solutions. This not only helped the team prioritize remediation but also clarified the business impact of each issue. By implementing best practices—such as enforcing HTTPS with properly configured SSL certificates, using SHA-256 for checksums, and updating insecure dependencies—I was able to strengthen the system’s defenses without causing major disruptions.
Secure coding is crucial because software often serves as the gateway to sensitive data. A single flaw can result in data breaches, regulatory penalties, and long-term reputational harm. In this context, software security offers more than just technical protection—it builds trust. When clients feel confident their information is safe, they’re more likely to engage and remain loyal. For the organization, secure practices also reduce maintenance costs, support regulatory compliance, and foster a culture of accountability.

One of the more challenging parts of the vulnerability assessment was tracing the root causes of issues hidden deep within third-party dependencies. Artemis Financial relied heavily on external libraries, and untangling which ones introduced risks like known CVEs (Common Vulnerabilities and Exposures) required not just automated scans but a good amount of manual investigation. Sometimes, a single outdated transitive dependency would go unnoticed unless you really dug into the dependency tree.
On the helpful side, the structured nature of the OWASP Dependency-Check reports was a game-changer. They not only flagged vulnerabilities but also suggested upgraded versions or links to official fixes. That structure made it easier to prioritize which issues to remediate first and gave the development team a clear path forward.

To increase layers of security, I applied a defense-in-depth strategy by combining HTTPS enforcement, multi-factor authentication, checksum validation, dependency upgrades, and hardened server settings to guard against multiple threat vectors. In the future, I’d use a combination of automated tools like OWASP Dependency-Check, SAST, and DAST, along with threat modeling and security frameworks, to assess vulnerabilities and choose effective mitigation strategies.

To ensure the software remained both functional and secure, I ran comprehensive unit and integration tests alongside static code analysis and input validation to verify performance and catch vulnerabilities early. After refactoring, I re-executed all tests, conducted fresh security scans, and incorporated peer code reviews to detect any new weaknesses introduced in the process.

In future assignments, several resources and practices will be especially helpful. Tools like OWASP Dependency-Check are essential for identifying vulnerable libraries, particularly in Maven or Spring Boot projects. Static code analysis tools such as SonarQube and SpotBugs assist in spotting early issues in code quality and security. Testing frameworks like JUnit and Mockito ensure that functionality stays intact during development and refactoring. Adhering to secure coding guidelines—especially the OWASP Top Ten and NIST standards—reinforces best practices for handling authentication, input validation, and sensitive data. Using Git for version control allows for structured experimentation and rollback when needed, while peer code reviews offer a valuable layer of insight that automated tools might miss. Altogether, these tools and habits help establish a strong, secure, and maintainable development workflow.

You could show future employers your hands-on experience with secure software practices—like implementing HTTPS, configuring SSL/TLS, and using SHA-256 for data integrity—as well as your ability to assess and remediate vulnerabilities using tools such as OWASP Dependency-Check. These accomplishments, paired with your clear documentation and thorough testing post-refactoring, highlight both your technical proficiency and your ability to communicate complex security concepts effectively.
